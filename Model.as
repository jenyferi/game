package {	import flash.display.MovieClip;	import flash.events.Event;	public class Model extends MovieClip {		private var _boardArray:Array;		private var _boardSize:int = 8;		private var _emptyScanners:Array = [];				public function Model() {					}		public function createBoard():void {			var c:int = 0;			_boardArray = [];			var r:int = 0;						while (r < _boardSize) {				_boardArray[r] = [];				c = 0;				while (c < _boardSize) {					_boardArray[r][c] = new Ball();					_boardArray[r][c].setRowandCol(r, c);					++c;				}				++r;			}			var r2:int = 0;			while (r2 < _boardSize) {				eliminateMatches(_boardArray[r2]);				++r2;			}						fallBalls();		}				private function fallBalls():void {			var scanAndFalls:Array = [];						for (var i:int = 0; i < _emptyScanners.length; i++){				var emptyScanner:Scanner = _emptyScanners[i];				if (emptyScanner.dir == Scanner.DIR_DOWN){					var scannerLength:int = 0;					var fallLength:int = 0;					var initRow:int = -1;										for (var j:int = 0; j<_boardSize; j++){						var ball:Ball = _boardArray[j][emptyScanner.col];						if (!ball.isBlank()){							if (initRow == -1){								initRow = j;							}							scannerLength++;						}else {							if (fallLength == 0){								var fallScanner = new Scanner(_boardArray, initRow, emptyScanner.col, initRow+scannerLength, Scanner.DIR_DOWN);								trace(fallScanner + " " + fallLength);							}						}					}				}else {					/*for (var l:int = emptyScanner.col; l < emptyScanner.col+emptyScanner.length; l++){						for (var k:int = 0; k <=emptyScanner.row-1; k++){							var ball2:Ball = _boardArray[k][l];							if (!ball2.isBlank() && thingsToMove.indexOf(ball2 == -1)){								thingsToMove.push(ball2);							}						}					}*/				}			}		}		public function swapBalls(currentBall:Ball, previousBall:Ball):void {						function swap(one:Ball, two:Ball):void {				_boardArray[two.getRow()][two.getCol()] = one;				_boardArray[one.getRow()][one.getCol()] = two;				var r:int=two.getRow();				var c:int=two.getCol();				two.setRowandCol(one.getRow(), one.getCol());				one.setRowandCol(r, c);			}									if (! previousBall.isNeighbor(currentBall)) {				throw new Error("attempted to swap non-neighbors");			}						swap(currentBall, previousBall);						if (eliminateMatches([currentBall,previousBall])) {				//match detected				var sEvt:SwapEvent = new SwapEvent(SwapEvent.ON_YES_MATCH);				sEvt.ball1 = currentBall;				sEvt.ball2 = previousBall;				dispatchEvent(sEvt);			} else {				//no match detected				var sEvt2:SwapEvent = new SwapEvent(SwapEvent.ON_NO_MATCH);				sEvt2.ball1 = previousBall;				sEvt2.ball2 = currentBall;				dispatchEvent(sEvt2);				swap(previousBall, currentBall);			}		}		private function detectMatches(scanner:Scanner):Vector.<Scanner> {			var i:I;			var ballKind:int = 0;			var currKind:int = -1;			var runLength:int = 1;			var scanners:Vector.<Scanner> = new Vector.<Scanner>();						while (i = scanner.next()) {				ballKind = i.thing.getKind();				if (currKind != ballKind) {					if (! (currKind == 0) && runLength >= 3) {						scanners.push(scanner.slice(-(runLength + 1), -1));					}					runLength = 1;					currKind = ballKind;								} else {					runLength = runLength + 1;				}			}						if (! (currKind == 0) && runLength >= 3) {				scanners.push(scanner.slice(-runLength, 0));			}			return scanners;		}		private function eliminateMatches(ballArray:Array):Boolean {			var balls:Array = ballArray;			var clearedAnySlice:Boolean = false;			var ball:Ball;			var ballRow:int = 0;			var ballCol:int = 0;			var slicesDown:Vector.<Scanner>;			var slicesRight:Vector.<Scanner>;						function clearSlices (scanners:Vector.<Scanner>):void {				var scanner:Scanner;				var i:I;				for each (scanner in scanners) {					//trace(scanner);					_emptyScanners.push(scanner);										i = scanner.next();										while (i != null) {						var bEvt:BallEvent = new BallEvent(BallEvent.ON_EMPTY_BALL);						bEvt.ball = i.thing;						dispatchEvent(bEvt);												i.thing.changeToBlankKind();						clearedAnySlice = true;						i = scanner.next();					}				}			}						for each (ball in balls) {				ballRow = ball.getRow();				ballCol = ball.getCol();				slicesDown = detectMatches(new Scanner(_boardArray,0,ballCol,_boardSize,Scanner.DIR_DOWN));				slicesRight = detectMatches(new Scanner(_boardArray,ballRow,0,_boardSize,Scanner.DIR_RIGHT));				clearSlices(slicesDown);				clearSlices(slicesRight);			}						return clearedAnySlice;		}		public function getBoardArray():Array {			return _boardArray;		}		public function getBoardSize():int {			return _boardSize;		}		public function assertFidelity():void {			var c:int = 0;			var ball:Ball;			var r:int = 0;						while (r < _boardSize) {				c = 0;				while (c < _boardSize) {					ball = _boardArray[r][c];					if (ball == null) {						throw new Error();					}					if (ball.getRow() != r) {						throw new Error();					}					if (ball.getCol() != c) {						throw new Error();					}					++c;				}				++r;			}		}		public function dumpBoard():void {			var c:int = 0;			var boardString:String = "";			var r:int = 0;						while (r < _boardSize) {				c = 0;				while (c < _boardSize) {					boardString = boardString + (_boardArray[r][c].getKind() + " ");					++c;				}				boardString += "\n";				++r;			}			boardString += "----------------------";			trace(boardString);		}	}}